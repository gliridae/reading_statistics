{
  "description": "Value '20XX' seen in the queries is used in the database to mark books as 'finished with an unknown date'. It's based on my needs and preference but it can be either changed to something else (keep in mind that some of the queries below are extracting the first 4 characters of this string to create a 'Year') or left alone. The queries weren't made with performance with mind.",
  "views": [
    {
      "description": "Just a simple view to quickly and easily see all the information saved in the database.",
      "view": "create view if not exists 'All Info' as select book.isbn, stat.released, auth.name as 'author', ser.name as 'series', book.series_index as 'index', book.title, stat.chapters, stat.pages, stat.speed, stat.time, stat.finished from authors as auth left join series as ser using (author_id) left join books as book using (series_id) left join statistics as stat using (isbn) order by released;"
    },
    {
      "description": "An overview of all the unread book series. 'Oldest book' is a date when the first book in the series was released.",
      "view": "create view if not exists 'Unread Series by Date' as select * from (select min(stat.Released) as 'Oldest book', auth.name as Author, ser.name as Series, count(coalesce(stat.Finished, '')) as Released, count(stat.Finished) as Finished, count(coalesce(stat.Finished, '')) - count(stat.Finished) as Unread from authors as auth left join series as ser using (author_id) left join books as book using (series_id) left join statistics as stat using (isbn) group by ser.series_id order by 'Oldest book') A where A.Unread != 0;"
    },
    {
      "description": "Similar to 'Unread Series by Date' but this time all the books are grouped by the author instead of the series.",
      "view": "create view if not exists 'Unread Author by Date' as select * from (select min(stat.Released) as 'Oldest book', auth.name as Author, count(coalesce(stat.Finished, '')) as Released, count(stat.Finished) as Finished, count(coalesce(stat.Finished, '')) - count(stat.Finished) as Unread from authors as auth left join series as ser using (author_id) left join books as book using (series_id) left join statistics as stat using (isbn) group by auth.Name order by 'Oldest book') A where A.Unread != 0;"
    },
    {
      "description": "This one is a bit more complicated than the previous queries. First of all, it's grouping the books by the year in which books were read. Then it shows the total number of finished books including the sum of their chapters and pages. After that it shows the minimum, maximum and average reading speed (calculated as words per minute) followed by minimum, maximum and average time (in hours) needed to read a book with an additional total time spent reading books in each year. At the end are the calculations to get the average time per chapter and time per page. The last row named 'Global' is showing the calculations on data about all read books instead of being limited to a single year. I might use this data in the future to programmatically generate charts just to learn something new.",
      "view": "create view if not exists 'Statistics [read] by Year' as with A as (select 'Global' as Year, count(*) as Finished, sum(Chapters) as Chapters, sum(Pages) as Pages from statistics where Finished is not null), B as (select 'Global' as Year, printf('%.2f', min(s.speed)) as 'Speed (min [w/min])', printf('%.2f', max(s.speed)) as 'Speed (max [w/min])', printf('%.2f', avg(s.speed)) as 'Speed (avg [w/min])', printf('%.2f', min(s.time)) as 'Time (min [h])', printf('%.2f', max(s.time)) as 'Time (max [h])', printf('%.2f', avg(s.time)) as 'Time (avg [h])', printf('%.2f', sum(s.time)) as 'Time (sum [h])', printf('%02i:%02i:%02i', (sum(s.time) / sum(chapters) % 3600), (sum(s.time) / sum(chapters) * 3600) / 60, (sum(s.time) / sum(chapters) * 3600) % 60) as 'Time/Chapter', printf('%02i:%02i:%02i', (sum(s.time) / sum(pages) % 3600), (sum(s.time) / sum(pages) * 60) % 60, (sum(s.time) / sum(pages) * 3600) % 60) as 'Time/Page' from statistics as s where Finished is not null and substr(finished, 1, 4) != '20XX') select substr(s.finished, 1, 4) as Year, count(*) as Finished, sum(chapters) as Chapters, sum(pages) as Pages, printf('%.2f', min(s.speed)) as 'Speed (min [w/min])', printf('%.2f', max(s.speed)) as 'Speed (max [w/min])', printf('%.2f', avg(s.speed)) as 'Speed (avg [w/min])', printf('%.2f', min(s.time)) as 'Time (min [h])', printf('%.2f', max(s.time)) as 'Time (max [h])', printf('%.2f', avg(s.time)) as 'Time (avg [h])', printf('%.2f', sum(s.time)) as 'Time (sum [h])', printf('%02i:%02i:%02i', (sum(s.time) / sum(chapters) % 3600), (sum(s.time) / sum(chapters) * 3600) / 60, (sum(s.time) / sum(chapters) * 3600) % 60) as 'Time/Chapter', printf('%02i:%02i:%02i', (sum(s.time) / sum(pages) % 3600), (sum(s.time) / sum(pages) * 60) % 60, (sum(s.time) / sum(pages) * 3600) % 60) as 'Time/Page' from statistics as s where finished is not null and substr(s.Finished, 1, 4) = '20XX' group by Year union all select substr(s.finished, 1, 4) as Year, count(*) as Finished, sum(chapters) as Chapters, sum(pages) as Pages, printf('%.2f', min(s.speed)) as 'Speed (min [w/min])', printf('%.2f', max(s.speed)) as 'Speed (max [w/min])', printf('%.2f', avg(s.speed)) as 'Speed (avg [w/min])', printf('%.2f', min(s.time)) as 'Time (min [h])', printf('%.2f', max(s.time)) as 'Time (max [h])', printf('%.2f', avg(s.time)) as 'Time (avg [h])', printf('%.2f', sum(s.time)) as 'Time (sum [h])', printf('%02i:%02i:%02i', (sum(s.time) / sum(chapters) % 3600), (sum(s.time) / sum(chapters) * 3600) / 60, (sum(s.time) / sum(chapters) * 3600) % 60) as 'Time/Chapter', printf('%02i:%02i:%02i', (sum(s.time) / sum(pages) % 3600), (sum(s.time) / sum(pages) * 60) % 60, (sum(s.time) / sum(pages) * 3600) % 60) as 'Time/Page' from statistics as s where Finished is not null and substr(s.finished, 1, 4) != '20XX' group by Year union all select printf('%.*c', 8, '-') as Year, printf('%.*c', 11, '-') as Finished, printf('%.*c', 12, '-') as Chapters, printf('%.*c', 8, '-') as Pages, printf('%.*c', 24, '-') as 'Speed (min [w/min])', printf('%.*c', 24, '-') as 'Speed (max [w/min])', printf('%.*c', 24, '-') as 'Speed (avg [w/min])', printf('%.*c', 17, '-') as 'Time (min [h])', printf('%.*c', 18, '-') as 'Time (max [h])', printf('%.*c', 17, '-') as 'Time (avg [h])', printf('%.*c', 16, '-') as 'Time (sum [h])', printf('%.*c', 17, '-') as 'Time/Chapter', printf('%.*c', 14, '-') as 'Time/Page' union all select A.*, B.'Speed (min [w/min])', B.'Speed (max [w/min])', B.'Speed (avg [w/min])', B.'Time (min [h])', B.'Time (max [h])', B.'Time (avg [h])', B.'Time (sum [h])', B.'Time/Chapter', B.'Time/Page' from A join B using (Year);"
    },
    {
      "description": "The goal with this query was to provide some statistics for the books that are still waiting to be read. First of all the books are grouped by the year in release date, then we have the total number of released, finished and unread books followed by statistics about chapters and pages ([t] = total, [r] = read, [u] = unread) and total reading time if some of the books have been read. Lastly, there are estimated times needed to finish all unread books from each year using an average time needed to finish a chapter ('Estimate [c]' = 'time per chapter' * chapters) or page ('Estimate [p]' = 'time per page' * pages) with column 'Estimate [a]' being their average.",
      "view": "create view if not exists 'Statistics [unread] by Year' as with E as (select 'Global' as Date, printf('%02i:%02i:%02i', (sum(s.time) / sum(chapters)), (sum(s.time) / sum(chapters) * 60) % 60, (sum(s.time) / sum(chapters) * 3600) % 60) as 'Time/Chapter', printf('%02i:%02i:%02i', (sum(s.time) / sum(pages)), (sum(s.time) / sum(pages) * 60) % 60, (sum(s.time) / sum(pages) * 3600) % 60) as 'Time/Page', (sum(s.time) / sum(chapters)) as per_chapter, (sum(s.time) / sum(pages)) as per_page from statistics as s where Finished is not null and substr(s.finished, 1, 4) != '20XX'), U as (select substr(s.released, 1, 4) as Date, sum(chapters) as unread_chapters, sum(pages) as unread_pages from statistics as s where s.finished is NULL group by Date), R as (select substr(s.released, 1, 4) as Date, sum(chapters) as read_chapters, sum(pages) as read_pages from statistics as s where s.finished is not NULL group by Date), G as (select 'Global' as Date, (select sum(chapters) from statistics as s where s.finished is not NULL) as read_chapters, (select sum(pages) from statistics as s where s.finished is not NULL) as read_pages, sum(chapters) as unread_chapters, sum(pages) as unread_pages from statistics as s where s.finished is NULL) select substr(s.released, 1, 4) as Year, count(*) as Released, count(s.finished) as Finished, count(*) - count(s.finished) as Unread, ifnull(sum(s.chapters), 0) as 'Chapters [t]', ifnull(read_chapters, 0) as 'Chapters [r]', ifnull(unread_chapters, 0) as 'Chapters [u]', ifnull(sum(s.pages), 0) as 'Pages [t]', ifnull(read_pages, 0) as 'Pages [r]', ifnull(unread_pages, 0) as 'Pages [u]', ifnull(sum(s.time), '0.00') as 'Time [r]', printf('%02i:%02i:%02i', ((select per_chapter from E) * unread_chapters), ((select per_chapter from E) * unread_chapters) * 60 % 60, ((select per_chapter from E) * unread_chapters) * 3600 % 60) as 'Estimate [c]', printf('%02i:%02i:%02i', ((select per_page from E) * unread_pages), ((select per_page from E) * unread_pages) * 60 % 60, ((select per_page from E) * unread_pages) * 3600 % 60) as 'Estimate [p]', printf('%02i:%02i:%02i', ((select per_chapter from E) * unread_chapters + (select per_page from E) * unread_pages) / 2, ((select per_chapter from E) * unread_chapters + (select per_page from E) * unread_pages) * 60 % 60 / 2, ((select per_chapter from E) * unread_chapters + (select per_page from E) * unread_pages) * 3600 % 60 / 2) as 'Estimate [a]' from statistics as s left join R on R.Date = Year left join U on U.Date = Year group by Year having Unread > 0 union all select printf('%.*c',  8, '-') as Year, printf('%.*c',  8, '-') as Released, printf('%.*c',  8, '-') as Finished, printf('%.*c',  8, '-') as Unread, printf('%.*c',  8, '-') as 'Chapters [t]', printf('%.*c',  8, '-') as 'Chapters [r]', printf('%.*c',  8, '-') as 'Chapters [u]', printf('%.*c',  8, '-') as 'Pages [t]', printf('%.*c',  8, '-') as 'Pages [r]', printf('%.*c',  8, '-') as 'Pages [u]', printf('%.*c',  8, '-') as 'Time [r]', printf('%.*c',  8, '-') as 'Estimate [c]', printf('%.*c',  8, '-') as 'Estimate [p]', printf('%.*c',  8, '-') as 'Estimate [a]' union all select 'Global' as Year, count(s.released) as Released, count(s.finished) as Finished, count(*) - count(s.finished) as Unread, sum(s.chapters) as 'Chapters [t]', read_chapters as 'Chapters [r]', unread_chapters  as 'Chapters [u]', sum(s.pages) as 'Pages [t]', read_pages as 'Pages [r]', unread_pages as 'Pages [u]', sum(s.time) as 'Time [r]', printf('%02i:%02i:%02i', ((select per_chapter from E) * unread_chapters), ((select per_chapter from E) * unread_chapters) * 60 % 60, ((select per_chapter from E) * unread_chapters) * 3600 % 60) as 'Estimate [c]', printf('%02i:%02i:%02i', ((select per_page from E) * unread_pages), ((select per_page from E) * unread_pages) * 60 % 60, ((select per_page from E) * unread_pages) * 3600 % 60) as 'Estimate [p]', printf('%02i:%02i:%02i', ((select per_chapter from E) * unread_chapters + (select per_page from E) * unread_pages) / 2, ((select per_chapter from E) * unread_chapters + (select per_page from E) * unread_pages) * 60 % 60 / 2, ((select per_chapter from E) * unread_chapters + (select per_page from E) * unread_pages) * 3600 % 60 / 2) as 'Estimate [a]' from statistics as s join G on 'Global' = G.Date;"
    },
    {
      "description": "This query is meant to show the estimated times needed to finish each book (based on calculated average times needed to finish chapter or page) while also showing how those estimates compare to the actual time needed to finish the books. As the name of the view implies, the calculated estimates for the finished books will not change even when new books have been read because the calculations only look at the books finished until the day before each book was finished. That means that the first finished book will have the estimates equal to '00:00:00' because there are no books to calculate those values.",
      "view": "create view if not exists 'Time taken vs Historical estimates Comparison' as with E as (select 'Global' as Date, printf('%02i:%02i:%02i', (sum(s.time) / sum(chapters)), (sum(s.time) / sum(chapters) * 60) % 60, (sum(s.time) / sum(chapters) * 3600) % 60) as 'Time/Chapter', printf('%02i:%02i:%02i', (sum(s.time) / sum(pages)), (sum(s.time) / sum(pages) * 60) % 60, (sum(s.time) / sum(pages) * 3600) % 60) as 'Time/Page', (sum(s.time) / sum(chapters)) as per_chapter, (sum(s.time) / sum(pages)) as per_page from statistics as s where s.finished is not null and substr(s.finished, 1, 4) != '20XX'), H as (select s1.finished as 'Finished', printf('%02i:%02i:%02i', (sum(s2.time) / sum(s2.chapters)), (sum(s2.time) / sum(s2.chapters) * 60) % 60, (sum(s2.time) / sum(s2.chapters) * 3600) % 60) as 'Time/Chapter', printf('%02i:%02i:%02i', (sum(s2.time) / sum(s2.pages)), (sum(s2.time) / sum(s2.pages) * 60) % 60, (sum(s2.time) / sum(s2.pages) * 3600) % 60) as 'Time/Page', (sum(s2.Time) / sum(s2.chapters)) as per_chapter, (sum(s2.Time) / sum(s2.pages)) as per_page from statistics s1 inner join statistics as s2 on s2.finished < s1.finished where s1.finished not in ('20XX') group by s1.finished order by s1.finished), EX as (select min(s.finished) as 'Finished', printf('00:00:00') as 'Time/Chapter', printf('00:00:00') as 'Time/Page', 0 as per_chapter, 0 as per_page from statistics s union select s.finished, printf('00:00:00') as 'Time/Chapter', printf('00:00:00') as 'Time/Page', 0 as per_chapter, 0 as per_page from statistics s where s.finished = '20XX')select s.isbn, s.released, s.finished, auth.name as 'Author', ser.name as 'Series', b.series_index as 'Index', b.title as 'Title', s.chapters as 'Chapters', s.pages as 'Pages', iif(s.time is not null, printf('%02i:%02i:%02i', s.time, (s.time * 60) % 60, (s.time * 3600) % 60), null) as 'Time taken', printf('%02i:%02i:%02i', ((select per_chapter from E) * s.chapters), ((select per_chapter from E) * s.chapters) * 60 % 60, ((select per_chapter from E) * s.chapters) * 3600 % 60) as 'Estimate [c]', printf('%02i:%02i:%02i', ((select per_page from E) * s.pages), ((select per_page from E) * s.pages) * 60 % 60, ((select per_page from E) * s.pages) * 3600 % 60) as 'Estimate [p]', printf('%02i:%02i:%02i', ((select per_chapter from E) * s.chapters + (select per_page from E) * s.pages) / 2, ((select per_chapter from E) * s.chapters + (select per_page from E) * s.pages) * 60 % 60 / 2, ((select per_chapter from E) * s.chapters + (select per_page from E) * s.pages) * 3600 % 60 / 2) as 'Estimate [a]' from statistics as s join books as b using (isbn) join series as ser using (series_id) join authors as auth using (author_id) where s.Finished is null union select s.isbn, s.released, s.finished, auth.name as 'Author', ser.name as 'Series', b.series_index as 'Index', b.title as 'Title', s.chapters as 'Chapters', s.pages as 'Pages', iif(s.time is not null, printf('%02i:%02i:%02i', s.time, (s.time * 60) % 60, (s.time * 3600) % 60), null) as 'Time taken', printf('%02i:%02i:%02i', ((H.per_chapter) * s.chapters), ((H.per_chapter) * s.chapters) * 60 % 60, ((H.per_chapter) * s.chapters) * 3600 % 60) as 'Estimate [c]', printf('%02i:%02i:%02i', ((H.per_page) * s.pages), ((H.per_page) * s.pages) * 60 % 60, ((H.per_page) * s.pages) * 3600 % 60) as 'Estimate [p]', printf('%02i:%02i:%02i', ((H.per_chapter) * s.chapters + (H.per_page) * s.pages) / 2, ((H.per_chapter) * s.chapters + (H.per_page) * s.pages) * 60 % 60 / 2, ((H.per_chapter) * s.chapters + (H.per_page) * s.pages) * 3600 % 60 / 2) as 'Estimate [a]' from statistics as s join books as b using (isbn) join series as ser using (series_id) join authors as auth using (author_id) join H using(finished) where s.Finished not in ('20XX') union select s.isbn, s.released, s.finished, auth.name as 'Author', ser.name as 'Series', b.series_index as 'Index', b.title as 'Title', s.chapters as 'Chapters', s.pages as 'Pages', iif(s.time is not null, printf('%02i:%02i:%02i', s.time, (s.time * 60) % 60, (s.time * 3600) % 60), null) as 'Time taken', printf('%02i:%02i:%02i', ((EX.per_chapter) * s.chapters), ((EX.per_chapter) * s.chapters) * 60 % 60, ((EX.per_chapter) * s.chapters) * 3600 % 60) as 'Estimate [c]', printf('%02i:%02i:%02i', ((EX.per_page) * s.pages), ((EX.per_page) * s.pages) * 60 % 60, ((EX.per_page) * s.pages) * 3600 % 60) as 'Estimate [p]', printf('%02i:%02i:%02i', ((EX.per_chapter) * s.chapters + (EX.per_page) * s.pages) / 2, ((EX.per_chapter) * s.chapters + (EX.per_page) * s.pages) * 60 % 60 / 2, ((EX.per_chapter) * s.chapters + (EX.per_page) * s.pages) * 3600 % 60 / 2) as 'Estimate [a]' from statistics as s join books as b using (isbn) join series as ser using (series_id) join authors as auth using (author_id) join EX using(Finished) order by s.released;"
    }
  ]
}
